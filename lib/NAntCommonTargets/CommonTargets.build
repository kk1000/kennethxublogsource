<?xml version="1.0" ?>
<project>
  <property name="nant.settings.currentframework"  value="net-2.0" overwrite="false" />
  <property name="solution.home"        value="${path::get-full-path('.')}" overwrite="false"/>
  <property name="build.configuration"  value="Debug" overwrite="false"/>
  <property name="build.project.name"   value="${project::get-name()}" overwrite="false" />
  <property name="build.output.dir"     value="${solution.home}\build\${build.project.name}\${build.configuration}" overwrite="false" />
  <property name="coverage.output.dir"  value="${solution.home}\build\TestAndCoverage" overwrite="false"/>
  <property name="fail.onerror"         value="true" overwrite="false"/>
  <property name="build.assembly.all"   value="${build.project.name}\${build.configuration}\${build.project.name}" overwrite="false"/>
  <property name="application.version"  value="1.0.0" overwrite="false" />
  <property name="useSubversion"        value="true"/>
  <property name="UML.publish.home" value="${solution.home}\doc\UML" overwrite="false" />
  
  <!-- Set NAnt global properties -->
  <property name="path.nunit.console"           value="nunit-console.exe" overwrite="false"/>
  <property name="path.ncover.console"          value="NCover.Console.exe" overwrite="false"/>
  <property name="path.ncoverexplorer.console"  value="NCoverExplorer.Console.exe" overwrite="false"/>
  <property name="path.svn"                     value="svn.exe" overwrite="false"/>
  <property name="path.fxcopcmd.exe"            value="fxcopcmd.exe" overwrite="false" />
  <property name="path.sandcastle.home"         value="C:\Program Files\Sandcastle" overwrite="false" />
  <property name="path.helpcomp.exe"            value="hhc.exe" overwrite="false"/>

  <!-- Generates AssemblyVersion.cs -->
  <target name="generateAssemblyVersion"
          description="Generate the AssemblyVersion.cs file and ensure to revert back on exit">
    <property name="nant.onfailure" value="revertAssemblyVersion"/>
    <property name="nant.onsuccess" value="revertAssemblyVersion"/>
    <call target="generateAssemblyVersionNoRevert"/>
  </target>

  <target name="generateAssemblyVersionNoRevert" depends="getSubversionRevision"
          description="Generate the AssemblyVersion.cs file">
    <property name="version" value="${application.version}.${repository.revision}"/>
    <!--Create the AssemblyVersion.cs file.-->
    <asminfo output="AssemblyVersion.cs" language="CSharp" if="${useSubversion}">
      <imports>
        <import namespace="System"/>
        <import namespace="System.Reflection"/>
        <import namespace="System.Runtime.InteropServices"/>
      </imports>
      <attributes>
        <attribute type="AssemblyTrademarkAttribute" value=""/>
        <attribute type="AssemblyCultureAttribute" value=""/>
        <attribute type="AssemblyVersionAttribute" value="${version}"/>
        <attribute type="AssemblyFileVersionAttribute" value="${version}"/>
      </attributes>
    </asminfo>
  </target>

  <!-- To cleanup the generated AssemblyVersion.cs -->
  <target name="revertAssemblyVersion" description="Revert the changes done to the AssemblyVersion.cs file">
    <exec program="${path.svn}" if="${useSubversion}">
      <arg value="revert"/>
      <arg value="AssemblyVersion.cs"/>
    </exec>
  </target>

  <target name="getSubversionRevision" description="Retreive the Subversion revision number">
    <!--Retrieve subversion revision number -->
    <mkdir dir="${solution.home}\build" if="${not directory::exists(solution.home + '\build')}" />

    <echo message="Retrieving Subversion revision number"/>
    <property name="repository.revision" value="0"/>
      <trycatch>
        <try>
          <exec
            program="${path.svn}"
            commandline = 'info "${solution.home}" --xml'
            output="${solution.home}\build\_revision.xml"/>
          <xmlpeek
            file="${solution.home}\build\_revision.xml"
            xpath="/info/entry/commit/@revision"
            property="repository.revision"/>
        </try>
        <catch property="failure">
          <echo message="Unable to retrieve Subversion revision number: ${failure}"/>
          <property name="useSubversion" value="false"/>
        </catch>
      </trycatch>
    <echo message="Using Subversion revision number: ${repository.revision}"/>
  </target>

  <target name="runFxCop">
    <!-- Below is bad, FIXME -->
    <!--
    <exec program="${path.fxcopcmd.exe}" failonerror="false">
      <arg value="/p:&quot;${solution.home}\src\${build.project.name}\FxCop\ccnet.fxcop&quot;"/>
      <arg value="/o:&quot;${solution.home}\build\${build.project.name}\FxCop\ccnet-fxcop.xml&quot;" />
    </exec>
    -->
  </target>

  <target name="buildSolution"  depends="generateAssemblyVersion">
    <property name="build.solution.file" value="${build.project.name}.sln" overwrite="false" />
    <msbuild project="${build.solution.file}" target="Build" verbosity="Minimal">
      <property name="Configuration" value="${build.configuration}" />
      <property name="ApplicationRevision" value="${repository.revision}"/>
      <property name="MSBuildExtensionsPath" value="${solution.home}\dependency\MSBuild"
		if="${directory::exists(solution.home+'\dependency\MSBuild')}"/>
      <arg value="/nologo"/>
    </msbuild>
  </target>

  <target name="runSandcastle" description="Generate Sandcastle API documentation">
    <!-- Important Path -->
    <property name="sandcastle.output.name" value="${project::get-name()}" overwrite="false" />
    <property name="sandcastle.work.dir" value="${solution.home}\doc\Sandcastle" overwrite="false"/>
    <property name="sandcastle.output.dir" value="${sandcastle.work.dir}\Output" overwrite="false"/>
    <property name="sandcastle.path" value="${path.sandcastle.home}" />
    <property name="sandcastle.xslt" value="${path.sandcastle.home}\ProductionTransforms" />
    <property name="sandcastle.dependency.all" value="" overwrite="false" />

    <!-- Executables -->
    <property name="sandcastle.mrefbuilder.exe"
              value="${sandcastle.path}\productiontools\mrefbuilder.exe" />
    <property name="sandcastle.buildassembler.exe"
              value="${sandcastle.path}\productiontools\buildassembler.exe" />
    <property name="sandcastle.xsltransform.exe"
              value="${sandcastle.path}\productiontools\xsltransform.exe" />

    <mkdir dir="${sandcastle.work.dir}" if="${not directory::exists(sandcastle.work.dir)}"/>

    <property name="build.assembly.argline" value="" />
    <foreach item="String" delim=";" property="build.assembly" in="${build.assembly.all}">
      <property name="build.assembly.dll.path" value="&quot;${solution.home}\build\${build.assembly}.dll&quot;" />
      <property name="build.assembly.argline" value="${build.assembly.argline} ${build.assembly.dll.path}" />
    </foreach>

    <property name="sandcastle.dependency.argline" value="" />
    <foreach item="String" delim=";" property="sandcastle.dependency" in="${sandcastle.dependency.all}">
      <property name="sandcastle.dependency.argline"
                value="${sandcastle.dependency.argline} &quot;/dep:${sandcastle.dependency}&quot;" />
    </foreach>

    <exec  program="${sandcastle.mrefbuilder.exe}"
        basedir="${sandcastle.path}\ProductionTools"
        workingdir="${sandcastle.work.dir}" >
      <environment>
        <variable name="DXROOT" value="${path.sandcastle.home}" />
      </environment>
      <arg line="${build.assembly.argline}" />
      <arg line="${sandcastle.dependency.argline}" />
      <arg value="/out:reflection.org" />
    </exec>

    <foreach item="String" delim=";" property="build.assembly" in="${build.assembly.all}">
      <copy todir="${sandcastle.work.dir}\comments" flatten="true" verbose="true" >
        <fileset basedir="${solution.home}\build">
          <include name="${build.assembly}.xml"/>
        </fileset>
      </copy>
    </foreach>

    <checksum algorithm="MD5" fileext="MD5">
      <fileset>
        <include name="${sandcastle.work.dir}\comments\*.xml"/>
      </fileset>
    </checksum>
    <trycatch>
      <try>
        <foreach item="File" property="filename">
          <in>
            <items>
              <include name="${sandcastle.work.dir}\comments\*.xml" />
            </items>
          </in>
          <do>
            <exec program="fc" output="${filename}.diff">
              <arg value="${filename}.MD5"/>
              <arg value="${filename}.PREV.MD5"/>
            </exec>
          </do>
        </foreach>
      </try>
      <catch>
        <call target="executeSandcastle"/>
        <foreach item="File" property="filename">
          <in>
            <items>
              <include name="${sandcastle.work.dir}\comments\*.xml" />
            </items>
          </in>
          <do>
            <move file="${filename}.MD5" tofile="${filename}.PREV.MD5" overwrite="true"/>
          </do>
        </foreach>
        </catch>
    </trycatch>
  </target>

  <target name="executeSandcastle">
    <exec  program="${sandcastle.xsltransform.exe}"
        basedir="${sandcastle.path}\ProductionTools"
        workingdir="${sandcastle.work.dir}" >
      <arg value="/arg:project=Project,IncludeAllMembersTopic=true" />
      <arg value="/xsl:&quot;${sandcastle.xslt}\ApplyVSDocModel.xsl&quot; reflection.org" />
      <arg value="/xsl:&quot;${sandcastle.xslt}\AddFriendlyFilenames.xsl&quot; /out:reflection.xml" />
    </exec>

    <exec  program="${sandcastle.xsltransform.exe}"
        basedir="${sandcastle.path}\ProductionTools"
        workingdir="${sandcastle.work.dir}" >
      <arg value="/xsl:&quot;${sandcastle.xslt}\ReflectionToManifest.xsl&quot; reflection.xml /out:manifest.xml" />
    </exec>

    <mkdir failonerror="false" dir="${sandcastle.output.dir}" />
    <mkdir failonerror="false" dir="${sandcastle.output.dir}\html" />
    <mkdir failonerror="false" dir="${sandcastle.output.dir}\icons" />
    <mkdir failonerror="false" dir="${sandcastle.output.dir}\scripts" />
    <mkdir failonerror="false" dir="${sandcastle.output.dir}\styles" />


    <copy todir="${sandcastle.output.dir}">
      <fileset basedir="${sandcastle.path}\Presentation\vs2005\">
        <include name="icons\*" />
        <include name="scripts\*" />
        <include name="styles\*" />
      </fileset>
    </copy>

    <copy file="${sandcastle.path}\Presentation\vs2005\configuration\Sandcastle.config"
      tofile="${sandcastle.work.dir}/Sandcastle.config" overwrite="true"> 
      <filterchain>
        <replacestring from="&quot;comments.xml" to="&quot;${sandcastle.work.dir}\comments\*.xml" />
        <replacestring from="&quot;.\comments.xml" to="&quot;${sandcastle.work.dir}\comments\*.xml" />
      </filterchain>
    </copy>

    <exec  program="${sandcastle.buildassembler.exe}"
        basedir="${sandcastle.path}\ProductionTools"
        workingdir="${sandcastle.work.dir}" >
      <arg value="/config:${sandcastle.work.dir}/Sandcastle.config" />
      <arg value="manifest.xml" />
    </exec>

    <exec  program="${sandcastle.xsltransform.exe}"
        basedir="${sandcastle.path}\ProductionTools"
        workingdir="${sandcastle.work.dir}" >
      <arg value="/xsl:&quot;${sandcastle.xslt}\ReflectionToChmProject.xsl&quot; reflection.xml /out:Output\${sandcastle.output.name}.hhp" />
    </exec>

    <exec  program="${sandcastle.xsltransform.exe}"
        basedir="${sandcastle.path}\ProductionTools"
        workingdir="${sandcastle.work.dir}" >
      <arg value="/xsl:&quot;${sandcastle.xslt}\createvstoc.xsl&quot; reflection.xml /out:${sandcastle.output.name}.TOC.xml" />
    </exec>
      <!-- // [KV 5/10/2007, 11:38 AM] Disable following for now as it needs more work.
      <exec  program="${sandcastle.xsltransform.exe}" 
          basedir="${sandcastle.path}\ProductionTools"
          workingdir="${sandcastle.work.dir}" >
          <arg value="/xsl:&quot;${sandcastle.xslt}\TocToChmContents.xsl&quot; ${sandcastle.output.name}.TOC.xml /out:Output\${sandcastle.output.name}.hhc" />
      </exec>
      
      <exec  program="${sandcastle.xsltransform.exe}" 
          basedir="${sandcastle.path}\ProductionTools"
          workingdir="${sandcastle.work.dir}" >
          <arg value="/xsl:&quot;${sandcastle.xslt}\ReflectionToChmIndex.xsl&quot; reflection.xml /out:Output\${sandcastle.output.name}.hhk" />
      </exec>

      <exec  program="${path.helpcomp.exe}" 
            workingdir="${sandcastle.work.dir}" >
        <arg value="Output\${sandcastle.output.name}.hhp" />
      </exec>


      <copy todir="${sandcastle.output.dir}\Output">
        <fileset basedir="${sandcastle.path}\Presentation\vs2005\">
          <include name="hxs\test*" />
        </fileset>
      </copy>

      <exec  program="XslTransform.exe" 
          basedir="${sandcastle.path}\ProductionTools"
          workingdir="${sandcastle.output.dir}" >
          <arg value="/xsl:&quot;${sandcastle.xslt}\TocToHxSContents.xsl&quot; ${sandcastle.output.name}.TOC.xml /out:Output\${sandcastle.output.name}.HxT" />
      </exec>
      -->
  </target>

  <target name="prepareCoverageXsl">
    <copy 
        file="${solution.home}/dependency/NCover/Coverage.xsl"
        todir="${coverage.output.dir}" />
  </target>

  <target name="createDistributionBinary" description="Create binary distribution files">
    <property name="distribution.home" 
              value="${solution.home}\bin"/>
    <property name="distribution.path" 
              value="${distribution.home}\net\2.0\${build.configuration}"/>
    <mkdir dir="${distribution.path}" if="${not directory::exists(distribution.path)}"/>
    <foreach item="String" delim=";" property="build.assembly" in="${build.assembly.all}">
      <copy todir="${distribution.path}" flatten="true" verbose="true" >
        <fileset basedir="${solution.home}\build">
          <include name="${build.assembly}.???"/>
        </fileset>
      </copy>
    </foreach>
    <echo message="Writing version ${version} to ${distribution.home}\VERSION.TXT"/>
    <echo message="${version}" file="${distribution.home}\VERSION.TXT" level="Error" />

  </target>

  <target name="generateCoverageReport">
    <echo message="Starting NCoverExplorer report generation..."/>
    
    <!-- Other attributes that can be used on ncoverexplorer element:               -->
    <!--   failMinimum="True" would fail the build if minimum coverage not met.     -->
    <!-- Remove the xmlReportName and/or htmlReportName attributes to not generate. -->
    <!-- Report types are 1=Module, 2=Namespace, 3=Namespace/Module, 4=Module/Class, 5=Function.-->
    <!-- Valid exclusion 'type' attributes are 'Assembly', 'Namespace' and 'Class'. -->
    <!-- See command line for which attributes are optional to alter behaviour.    -->

    <property name="coverage.satisfactory" value="80" overwrite="false"/>
    <property name="coverage.minimum" value="80" overwrite="false"/>

    <property name="coverage.assembly.exclusion.1" value="DummyAssemblyPlaceHolder" overwrite="false"/>
    <property name="coverage.assembly.exclusion.2" value="DummyAssemblyPlaceHolder" overwrite="false"/>
    <property name="coverage.assembly.exclusion.3" value="DummyAssemblyPlaceHolder" overwrite="false"/>
    
    <property name="coverage.namespace.exclusion.1" value="DummyNamespacePlaceHolder" overwrite="false"/>
    <property name="coverage.namespace.exclusion.2" value="DummyNamespacePlaceHolder" overwrite="false"/>
    <property name="coverage.namespace.exclusion.3" value="DummyNamespacePlaceHolder" overwrite="false"/>

    <property name="coverage.class.exclusion.1" value="DummyClassPlaceHolder" overwrite="false"/>
    <property name="coverage.class.exclusion.2" value="DummyClassPlaceHolder" overwrite="false"/>
    <property name="coverage.class.exclusion.3" value="DummyClassPlaceHolder" overwrite="false"/>

	  <property name="coverage.output.merge" value="${coverage.output.dir}\CoverageMerge.out"/>

    <delete>
      <fileset>
        <include name="${coverage.output.dir}\CoverageMerge.*" />
      </fileset>
    </delete>

    <trycatch>
      <try>
        <ncoverexplorer program="${path.ncoverexplorer.console}"
                projectName="${build.project.name}"
                reportType="4"
                outputDir="${coverage.output.dir}" 
                xmlReportName="CoverageReport.xml"
                htmlReportName="CoverageReport.html"
                mergeFileName="CoverageMerge.out"
                showExcluded="True"
                satisfactoryCoverage="${coverage.satisfactory}"
                minimumCoverage="${coverage.minimum}"
                failMinimum="True" >
          <fileset>
            <include name="${coverage.output.dir}\*.Coverage.xml"/>
          </fileset>
          <exclusions>
            <exclusion type="Class" pattern="*Exception" />
            <exclusion type="Assembly" pattern="*.UnitTest" />
            <exclusion type="Assembly" pattern="*.UnitTests" />
            <exclusion type="Assembly" pattern="*.Tests" />

            <exclusion type="Assembly" pattern="${coverage.assembly.exclusion.1}" />
            <exclusion type="Assembly" pattern="${coverage.assembly.exclusion.2}" />
            <exclusion type="Assembly" pattern="${coverage.assembly.exclusion.3}" />

            <exclusion type="Namespace" pattern="${coverage.namespace.exclusion.1}" />
            <exclusion type="Namespace" pattern="${coverage.namespace.exclusion.2}" />
            <exclusion type="Namespace" pattern="${coverage.namespace.exclusion.3}" />

            <exclusion type="Class" pattern="${coverage.class.exclusion.1}" />
            <exclusion type="Class" pattern="${coverage.class.exclusion.2}" />
            <exclusion type="Class" pattern="${coverage.class.exclusion.3}" />
          <!--
            <exclusion type="Assembly" pattern="*.Tests" />
            <exclusion type="Namespace" pattern="MyApp\.(\w*\.)?" isRegex="true" />
          -->
          </exclusions>
        </ncoverexplorer>
      </try>
      <finally>
        <property name="source.url.prefix"   overwrite="false"     value="../.." />
        <copy file="${coverage.output.merge}" 
            tofile="${coverage.output.dir}\CoverageMerge.xml" 
            if='${file::exists(coverage.output.merge)}'>
          <filterchain>
            <replacestring from="${solution.home}" to="" ignorecase="true" />
            <replacestring from="&lt;coverage" to="&lt;coverage sourceurlprefix='${source.url.prefix}'" />
            <replacestring from="\" to="/" />
          </filterchain>
        </copy>
      </finally>
    </trycatch>
  </target>

  <target name="runAllTestWithNCover" description="Code coverage test run." >

    <!-- Ensure we have a directory for the code coverage results -->
    <mkdir dir="${coverage.output.dir}" if="${not directory::exists(coverage.output.dir)}"/>
    
    <echo message="Starting nested NUnit test and code coverage projects..."/>
    <property name="fail.message" value=""/>
    <property name="test.failed" value="false"/>

    <foreach item="File" property="nestedbuild">
      <in>
        <items>
            <include name="${solution.home}/test/*Test/*Test.build" />
            <include name="${solution.home}/test/*Tests/*Tests.build" />
        </items>
      </in>
      <do>
        <trycatch>
          <try>
            <nant buildfile="${nestedbuild}" inheritall="false">
              <properties>
                <property name="path.nunit.console" value="${path.nunit.console}"/>
                <property name="path.ncover.console" value="${path.ncover.console}"/>
              </properties>
            </nant>
          </try>
          <catch property="failure">
            <property name="fail.message" value="${failure}"/>
            <property name="test.failed" value="true"/>
          </catch>
        </trycatch>
      </do>
    </foreach>

    <!-- If we had a test failure (and we are allowed to stop the build for a failure) then report it -->
    <fail if="${fail.onerror and test.failed}" message="${fail.message}"/>    
    
  </target>


  <target name="testWithCoverage" description="Run NUnit test with NCover" >

    <property name="build.test.assembly"       value="${build.project.name}.dll" />
    <property name="coverage.xml.file"         value="${coverage.output.dir}\${build.project.name}.Coverage.xml" />
    <property name="coverage.log.file"         value="${coverage.output.dir}\${build.project.name}.Coverage.log" />
    <property name="fail.message"              value="" />
    <property name="test.nunit.flags"          value="/labels /nologo" />
    <property name="test.results.xml"          value="${coverage.output.dir}\${build.test.assembly}.Results.xml" />
    <property name="coverage.assembly.list"    value="${string::replace(build.project.name, '.UnitTest', '')}" overwrite="false"/>

    <!-- Ensure we have a directory for the code coverage results -->
    <mkdir dir="${coverage.output.dir}" if="${not directory::exists(coverage.output.dir)}"/>

    <echo message="Starting NUnit code coverage run..."/>
    <property name="test.failed" value="false"/>
    <trycatch>
      <try>
        <ncover program="${path.ncover.console}"
            commandLineExe="${path.nunit.console}"
            commandLineArgs="${build.test.assembly} /xml=&quot;${test.results.xml}&quot; ${test.nunit.flags}"
            workingDirectory="${build.output.dir}"
            coverageFile="${coverage.xml.file}"
            logFile="${coverage.log.file}"
            assemblyList="${coverage.assembly.list}"
            />
      </try>
      <catch property="failure">
        <property name="test.failed" value="true"/>
        <property name="fail.message" value="Coverage test failed: ${failure}"/>
        <echo message="${fail.message}"/>
        <echo message="Please refer to the log message above for failed test case(s)." />
        <echo message="If there is no failed test case listed, NCover log file below might help to diagnose:" />
        <echo message="${coverage.log.file}" />
      </catch>
    </trycatch>
    
    <!-- If we had a test failure (and we are allowed to stop the build for a failure) then report it -->
    <fail if="${fail.onerror and test.failed}" message="${fail.message}"/>    
  </target>

  <target name="publishUML">
	<property name="UML.doc.all" value="${build.project.name}" overwrite="false"/>
    <foreach item="String" delim=";" property="UML.doc" in="${UML.doc.all}">
      <property name="UML.doc.file" value="${solution.home}\doc\${UML.doc}.vpp" />
      <if test="${property::exists('UML.'+ UML.doc + '.file')}">
        <property name="UML.doc.file" value="${property::get-value('UML.'+ UML.doc + '.file')}"/>
      </if>
      <property name="UML.out.path" value="${UML.publish.home}\${UML.doc}"/>
      <if test="${property::exists('UML.'+ UML.doc + '.out')}">
        <property name="UML.out.path" value="${property::get-value('UML.'+ UML.doc + '.out')}"/>
      </if>

      <mkdir dir="${UML.out.path}"/>
     <if test="${not file::up-to-date(UML.doc.file, UML.out.path + '\index.html')}">
       <echo message="Publishing ${UML.doc.file}"/>
       <echo message="To: ${UML.out.path}"/>
        <exec workingdir="C:\Program Files\VP Suite 3.1\scripts"  
              basedir="C:\Program Files\VP Suite 3.1\scripts" 
 	          program="ProjectPublisher.bat">
          <arg value='-project "${UML.doc.file}"' />
          <arg value='-out "${UML.out.path}"' />
        </exec>
      </if>
    </foreach>
  </target>
</project>